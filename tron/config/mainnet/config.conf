net {
  type = mainnet
}

storage {
  # Directory for storing persistent data
  db.version = 2
  db.engine = "LEVELDB"
  db.sync = false
  db.directory = "database"
  index.directory = "index"
  transHistory.switch = "on"

  # You can custom these 14 databases' configs:
  properties = [
    {
      name = "account"
      path = "storage_directory_test"
      createIfMissing = true
      paranoidChecks = true
      verifyChecksums = true
      compressionType = 1        # compressed with snappy
      blockSize = 4096           # 4  KB =         4 * 1024 B
      writeBufferSize = 10485760 # 10 MB = 10 * 1024 * 1024 B
      cacheSize = 10485760       # 10 MB = 10 * 1024 * 1024 B
      maxOpenFiles = 100
    },
    {
      name = "account-index"
      path = "storage_directory_test"
      createIfMissing = true
      paranoidChecks = true
      verifyChecksums = true
      compressionType = 1        # compressed with snappy
      blockSize = 4096           # 4  KB =         4 * 1024 B
      writeBufferSize = 10485760 # 10 MB = 10 * 1024 * 1024 B
      cacheSize = 10485760       # 10 MB = 10 * 1024 * 1024 B
      maxOpenFiles = 100
    }
  ]

  needToUpdateAsset = true

  # Data pruning
  # Uncomment these for lite node mode
  # properties = [
  #   {
  #     name = "block.needSyncCheck"
  #     value = true
  #   }
  # ]
}

node.discovery = {
  enable = true
  persist = true
  bind.ip = ""
  external.ip = null
}

node.backup {
  port = 10001
  priority = 8
  members = []
}

node {
  # Trust node for solidity node
  trustNode = "127.0.0.1:50051"

  # Expose wallet services
  walletExtensionApi = true

  listen.port = 18888

  connection.timeout = 2

  tcpNettyWorkThreadNum = 0

  udpNettyWorkThreadNum = 1

  # Number of validate sign thread, default availableProcessors / 2
  validateSignThreadNum = 16

  connectFactor = 0.3
  activeConnectFactor = 0.1

  maxActiveNodes = 30

  maxActiveNodesWithSameIp = 5

  minParticipationRate = 0

  # Check the peer data transfer
  isOpenFullTcpDisconnect = true

  p2p {
    version = 11111
  }

  active = [
    # Seed nodes for mainnet
    "3.225.171.164:18888",
    "52.53.189.99:18888",
    "18.196.99.16:18888",
    "34.253.187.192:18888",
    "52.56.56.149:18888",
    "35.180.51.163:18888",
    "54.252.224.209:18888",
    "18.228.15.36:18888",
    "52.15.93.92:18888",
    "34.220.77.106:18888",
    "13.127.47.162:18888",
    "13.124.62.58:18888",
    "13.229.128.108:18888",
    "35.182.37.246:18888",
    "47.254.16.55:18888",
    "47.254.146.147:18888",
    "47.254.27.69:18888",
    "47.91.246.252:18888",
    "47.91.216.69:18888",
    "39.106.220.120:18888"
  ]

  passive = []

  http {
    fullNodePort = 8090
    solidityPort = 8091
  }

  rpc {
    port = 50051
    # By default the rpc port will listen on all network interfaces
    # If you want to listen on one network interface, uncomment the line below
    # address = "127.0.0.1"

    solidityPort = 50061
    maxConnectionIdleInMillis = 60000
    minEffectiveConnection = 1
  }

  # Number of gRPC thread, default availableProcessors / 2
  rpcThreadNum = 16

  # The maximum number of concurrent calls permitted for each incoming connection
  maxConcurrentCallsPerConnection = 10

  # The HTTP/2 flow control window, default 1MB
  flowControlWindow = 1048576

  # Connection being idle for longer than which will be gracefully terminated
  maxConnectionIdleInMillis = 60000

  # Connection lasting longer than which will be gracefully terminated
  # default value 0, the connection is not been limited by time
  maxConnectionAgeInMillis = 0

  # The maximum message size allowed to be received on the server, default 4MB
  maxMessageSize = 4194304

  # The maximum size of header list allowed to be received, default 8192
  maxHeaderListSize = 8192

  # Transactions from the wallet are sent to be verified by this node
  # Optional value: local or remote
  transactionVerificationEnable = true

  # Support db allowing/disallowing query optimization
  queryOptimizationEnable = false

  # When outputting or calculating difficulty, whether to use maximum precision
  maxDifficultyEnabled = false
}

seed.node = {
  # List of seed nodes
  ip.list = []
}

genesis.block = {
  # Reserve balance
  assets = [
    {
      accountName = "Zion"
      accountType = "AssetIssue"
      address = "TLLM21wteSPs4hKjbxgmH1L6poyMjeTbHm"
      balance = "99000000000000000"
    },
    {
      accountName = "Sun"
      accountType = "AssetIssue"
      address = "TXmVpin5vq5gdZsciyyjdZgKRUju4st1wM"
      balance = "0"
    },
    {
      accountName = "Blackhole"
      accountType = "AssetIssue"
      address = "TLsV52sRDL79HXGGm9yzwKibb6BeruhUzy"
      balance = "-9223372036854775808"
    }
  ]

  witnesses = [
    {
      address: THKJYuUmMKKARNf7s2VT51g5uPY6KEqnat,
      url = "http://GR1.com",
      voteCount = 100000026
    },
    {
      address: TVDmPWGYxgi5DNeW8hXrzrhY8Y6zgxPNg4,
      url = "http://GR2.com",
      voteCount = 100000025
    },
    {
      address: TWKZN1JJPFydd5rMgMCV5aZTSiwmoksSZv,
      url = "http://GR3.com",
      voteCount = 100000024
    }
  ]

  timestamp = "0" # 2017-8-26 12:00:00

  parentHash = "0xe58f33f9baf9305dc6f82b9f1934ea8f0ade2defb951258d50167028c780351f"
}

localwitness = []

block = {
  needSyncCheck = false
  maintenanceTimeInterval = 21600000
  proposalExpireTime = 259200000 # 3 day: 259200000(ms)
}

# Transaction reference block, default is "head", configure to "solid" can avoid TaPos error
trx.reference.block = "head" # head;solid;

# This property sets the number of milliseconds after the creation of the transaction that is expired, default value is  60000.
# trx.expiration.timeInMilliseconds = 60000

vm = {
  supportConstant = true
  minTimeRatio = 0.0
  maxTimeRatio = 5.0
  saveInternalTx = false

  # In rare cases, transactions that will be within the specified maximum execution time (default 10(ms)) are re-executed.
  # maxRunTimeOfOneTx = 10

  # JIT contract VM
  # jit.enable = false
}

committee = {
  allowCreationOfContracts = 0  # Mainnet doesn't allow anyone to deploy smart contract
  allowAdaptiveEnergy = 0  # Mainnet adaptive energy limit
}

event.subscribe = {
  native = {
    useNativeQueue = true # if true, use native message queue, else use event plugin
    bindport = 5555 # bind port
    sendqueuelength = 1000 # max length of send queue
  }

  path = ""
  server = ""
  dbconfig = ""
  contractParse = true
  topics = [
    {
      triggerName = "block" # block trigger, the value can't be modified
      enable = false
      topic = "block" # plugin topic, the value could be modified
    },
    {
      triggerName = "transaction"
      enable = false
      topic = "transaction"
    },
    {
      triggerName = "contractevent"
      enable = false
      topic = "contractevent"
    },
    {
      triggerName = "contractlog"
      enable = false
      topic = "contractlog"
    },
    {
      triggerName = "solidity" # solidity block trigger, the value can't be modified
      enable = true            # enable trigger
      topic = "solidity"
    }
  ]

  filter = {
    fromblock = "" # the value could be "", "earliest" or a specified block number as the beginning of the queried range
    toblock = "" # the value could be "", "latest" or a specified block number as end of the queried range
    contractAddress = [
      "" # contract address you want to subscribe, if it's set to "", you will receive contract logs/events with any contract address.
    ]

    contractTopic = [
      "" # contract topic you want to subscribe, if it's set to "", you will receive contract logs/events with any contract topic.
    ]
  }
}

# the number of thread to process event
filterThread = 5
